# Active Veto System - Hypothesis Review Interface
# Implements the three-button interface for Dream Cycle hypothesis management

import asyncio
import json
import time
import os
from typing import Dict, Any, Optional, List, Callable
from pathlib import Path
import logging
from datetime import datetime, timedelta
from dataclasses import dataclass, asdict
from enum import Enum

class HypothesisStatus(Enum):
    """Status of a hypothesis."""
    PENDING = "pending"
    CONFIRMED = "confirmed"
    DENIED = "denied"
    CONDITIONAL = "conditional"

class HypothesisType(Enum):
    """Types of hypotheses generated by Dream Cycle."""
    BEHAVIORAL_PATTERN = "behavioral_pattern"
    COMMUNICATION_STYLE = "communication_style"
    PREFERENCE_CHANGE = "preference_change"
    EMOTIONAL_RESPONSE = "emotional_response"
    COGNITIVE_BIAS = "cognitive_bias"
    RELATIONSHIP_DYNAMIC = "relationship_dynamic"
    WORKFLOW_PATTERN = "workflow_pattern"
    DECISION_MAKING = "decision_making"

@dataclass
class DreamHypothesis:
    """A hypothesis generated by the Dream Cycle."""
    id: str
    pattern: str
    evidence: List[str]
    confidence: float
    created: float
    status: HypothesisStatus = HypothesisStatus.PENDING
    creator_response: Optional[str] = None
    conditional_context: Optional[str] = None
    reviewed_at: Optional[float] = None
    impact_score: float = 0.0
    category: HypothesisType = HypothesisType.BEHAVIORAL_PATTERN
    
    def __post_init__(self):
        if self.created is None:
            self.created = time.time()
        if self.confidence < 0 or self.confidence > 1:
            self.confidence = max(0, min(1, self.confidence))

@dataclass
class VetoSession:
    """A session of hypothesis review."""
    id: str
    hypotheses: List[DreamHypothesis]
    start_time: float
    end_time: Optional[float] = None
    completed: bool = False
    decisions_made: int = 0
    
    def __post_init__(self):
        if self.start_time is None:
            self.start_time = time.time()

class ActiveVetoSystem:
    """
    The Active Veto System manages the hypothesis review interface.
    
    Features:
    - Three-button interface (Confirm | Deny | Add Context)
    - Batch hypothesis review
    - Conditional branch creation
    - Impact scoring
    - Review history tracking
    - Smart prioritization
    """
    
    def __init__(self, brain_instance=None):
        self.brain = brain_instance
        self.pending_hypotheses: List[DreamHypothesis] = []
        self.review_history: List[VetoSession] = []
        self.current_session: Optional[VetoSession] = None
        self.veto_config_file = Path.home() / ".sallie" / "veto_config.json"
        self.load_config()
        
        # Review settings
        self.max_hypotheses_per_session = 5
        self.confidence_threshold = 0.3
        self.auto_confirm_threshold = 0.8
        self.session_timeout = 3600  # 1 hour
        
    def load_config(self):
        """Load veto system configuration."""
        try:
            if self.veto_config_file.exists():
                with open(self.veto_config_file, 'r') as f:
                    config = json.load(f)
                    self.max_hypotheses_per_session = config.get('max_hypotheses_per_session', 5)
                    self.confidence_threshold = config.get('confidence_threshold', 0.3)
                    self.auto_confirm_threshold = config.get('auto_confirm_threshold', 0.8)
                    self.session_timeout = config.get('session_timeout', 3600)
        except Exception as e:
            logging.warning(f"Failed to load veto config: {e}")
    
    def save_config(self):
        """Save veto system configuration."""
        try:
            self.veto_config_file.parent.mkdir(parents=True, exist_ok=True)
            config = {
                'max_hypotheses_per_session': self.max_hypotheses_per_session,
                'confidence_threshold': self.confidence_threshold,
                'auto_confirm_threshold': self.auto_confirm_threshold,
                'session_timeout': self.session_timeout
            }
            with open(self.veto_config_file, 'w') as f:
                json.dump(config, f, indent=2)
        except Exception as e:
            logging.error(f"Failed to save veto config: {e}")
    
    def add_hypothesis(self, hypothesis: DreamHypothesis):
        """Add a new hypothesis to the review queue."""
        # Filter low-confidence hypotheses
        if hypothesis.confidence < self.confidence_threshold:
            logging.debug(f"Filtered low-confidence hypothesis: {hypothesis.id}")
            return False
        
        # Auto-confirm very high confidence hypotheses
        if hypothesis.confidence >= self.auto_confirm_threshold:
            hypothesis.status = HypothesisStatus.CONFIRMED
            hypothesis.reviewed_at = time.time()
            hypothesis.creator_response = "Auto-confirmed due to high confidence"
            logging.info(f"Auto-confirmed hypothesis: {hypothesis.id}")
            return True
        
        # Add to pending queue
        self.pending_hypotheses.append(hypothesis)
        logging.info(f"Added hypothesis to review queue: {hypothesis.id}")
        return True
    
    def start_review_session(self) -> VetoSession:
        """Start a new hypothesis review session."""
        # Check if there's an active session
        if self.current_session and not self.current_session.completed:
            if time.time() - self.current_session.start_time < self.session_timeout:
                return self.current_session
        
        # Create new session
        session_id = f"session_{int(time.time())}"
        hypotheses_to_review = self.pending_hypotheses[:self.max_hypotheses_per_session]
        
        self.current_session = VetoSession(
            id=session_id,
            hypotheses=hypotheses_to_review,
            start_time=time.time()
        )
        
        # Remove from pending queue
        self.pending_hypotheses = self.pending_hypotheses[len(hypotheses_to_review):]
        
        logging.info(f"Started review session {session_id} with {len(hypotheses_to_review)} hypotheses")
        return self.current_session
    
    def confirm_hypothesis(self, hypothesis_id: str, creator_context: Optional[str] = None) -> bool:
        """Confirm a hypothesis."""
        if not self.current_session:
            logging.error("No active review session")
            return False
        
        for hypothesis in self.current_session.hypotheses:
            if hypothesis.id == hypothesis_id:
                hypothesis.status = HypothesisStatus.CONFIRMED
                hypothesis.reviewed_at = time.time()
                hypothesis.creator_response = creator_context or "Confirmed"
                hypothesis.impact_score = self._calculate_impact_score(hypothesis, "confirm")
                self.current_session.decisions_made += 1
                
                # Apply to brain if available
                if self.brain and hasattr(self.brain, 'apply_hypothesis'):
                    self.brain.apply_hypothesis(hypothesis)
                
                logging.info(f"Confirmed hypothesis: {hypothesis_id}")
                return True
        
        logging.error(f"Hypothesis not found: {hypothesis_id}")
        return False
    
    def deny_hypothesis(self, hypothesis_id: str, creator_context: Optional[str] = None) -> bool:
        """Deny a hypothesis."""
        if not self.current_session:
            logging.error("No active review session")
            return False
        
        for hypothesis in self.current_session.hypotheses:
            if hypothesis.id == hypothesis_id:
                hypothesis.status = HypothesisStatus.DENIED
                hypothesis.reviewed_at = time.time()
                hypothesis.creator_response = creator_context or "Denied"
                hypothesis.impact_score = self._calculate_impact_score(hypothesis, "deny")
                self.current_session.decisions_made += 1
                
                logging.info(f"Denied hypothesis: {hypothesis_id}")
                return True
        
        logging.error(f"Hypothesis not found: {hypothesis_id}")
        return False
    
    def add_context_to_hypothesis(self, hypothesis_id: str, context: str) -> bool:
        """Add context to a hypothesis (create conditional branch)."""
        if not self.current_session:
            logging.error("No active review session")
            return False
        
        for hypothesis in self.current_session.hypotheses:
            if hypothesis.id == hypothesis_id:
                hypothesis.status = HypothesisStatus.CONDITIONAL
                hypothesis.reviewed_at = time.time()
                hypothesis.conditional_context = context
                hypothesis.creator_response = f"Conditional: {context}"
                hypothesis.impact_score = self._calculate_impact_score(hypothesis, "conditional")
                self.current_session.decisions_made += 1
                
                # Apply conditional to brain if available
                if self.brain and hasattr(self.brain, 'apply_conditional_hypothesis'):
                    self.brain.apply_conditional_hypothesis(hypothesis, context)
                
                logging.info(f"Added context to hypothesis: {hypothesis_id}")
                return True
        
        logging.error(f"Hypothesis not found: {hypothesis_id}")
        return False
    
    def complete_session(self) -> Dict[str, Any]:
        """Complete the current review session."""
        if not self.current_session:
            return {"error": "No active session"}
        
        self.current_session.end_time = time.time()
        self.current_session.completed = True
        
        # Add to history
        self.review_history.append(self.current_session)
        
        # Generate session summary
        summary = {
            "session_id": self.current_session.id,
            "hypotheses_reviewed": len(self.current_session.hypotheses),
            "decisions_made": self.current_session.decisions_made,
            "duration": self.current_session.end_time - self.current_session.start_time,
            "confirmed": len([h for h in self.current_session.hypotheses if h.status == HypothesisStatus.CONFIRMED]),
            "denied": len([h for h in self.current_session.hypotheses if h.status == HypothesisStatus.DENIED]),
            "conditional": len([h for h in self.current_session.hypotheses if h.status == HypothesisStatus.CONDITIONAL]),
            "average_impact": sum(h.impact_score for h in self.current_session.hypotheses) / len(self.current_session.hypotheses) if self.current_session.hypotheses else 0
        }
        
        # Clear current session
        self.current_session = None
        
        logging.info(f"Completed review session: {summary}")
        return summary
    
    def get_pending_hypotheses(self, limit: int = 10) -> List[DreamHypothesis]:
        """Get pending hypotheses for review."""
        return self.pending_hypotheses[:limit]
    
    def get_session_status(self) -> Dict[str, Any]:
        """Get current session status."""
        if not self.current_session:
            return {
                "active_session": False,
                "pending_hypotheses": len(self.pending_hypotheses),
                "recent_sessions": len(self.review_history)
            }
        
        return {
            "active_session": True,
            "session_id": self.current_session.id,
            "hypotheses_count": len(self.current_session.hypotheses),
            "decisions_made": self.current_session.decisions_made,
            "session_duration": time.time() - self.current_session.start_time,
            "pending_hypotheses": len(self.pending_hypotheses),
            "recent_sessions": len(self.review_history)
        }
    
    def get_hypothesis_details(self, hypothesis_id: str) -> Optional[DreamHypothesis]:
        """Get detailed information about a specific hypothesis."""
        # Check current session
        if self.current_session:
            for hypothesis in self.current_session.hypotheses:
                if hypothesis.id == hypothesis_id:
                    return hypothesis
        
        # Check pending hypotheses
        for hypothesis in self.pending_hypotheses:
            if hypothesis.id == hypothesis_id:
                return hypothesis
        
        # Check review history
        for session in self.review_history:
            for hypothesis in session.hypotheses:
                if hypothesis.id == hypothesis_id:
                    return hypothesis
        
        return None
    
    def _calculate_impact_score(self, hypothesis: DreamHypothesis, decision: str) -> float:
        """Calculate the impact score of a hypothesis decision."""
        base_score = hypothesis.confidence
        
        # Adjust based on decision type
        if decision == "confirm":
            impact_multiplier = 1.0
        elif decision == "deny":
            impact_multiplier = -0.5
        elif decision == "conditional":
            impact_multiplier = 0.5
        else:
            impact_multiplier = 0.0
        
        # Adjust based on hypothesis type
        type_multipliers = {
            HypothesisType.BEHAVIORAL_PATTERN: 1.2,
            HypothesisType.COMMUNICATION_STYLE: 1.0,
            HypothesisType.PREFERENCE_CHANGE: 0.8,
            HypothesisType.EMOTIONAL_RESPONSE: 1.1,
            HypothesisType.COGNITIVE_BIAS: 0.9,
            HypothesisType.RELATIONSHIP_DYNAMIC: 1.3,
            HypothesisType.WORKFLOW_PATTERN: 0.7,
            HypothesisType.DECISION_MAKING: 1.0
        }
        
        type_multiplier = type_multipliers.get(hypothesis.category, 1.0)
        
        return base_score * impact_multiplier * type_multiplier
    
    def get_review_statistics(self) -> Dict[str, Any]:
        """Get comprehensive review statistics."""
        if not self.review_history:
            return {
                "total_sessions": 0,
                "total_hypotheses": 0,
                "confirmation_rate": 0.0,
                "denial_rate": 0.0,
                "conditional_rate": 0.0,
                "average_impact": 0.0
            }
        
        total_hypotheses = sum(len(session.hypotheses) for session in self.review_history)
        confirmed = sum(len([h for h in session.hypotheses if h.status == HypothesisStatus.CONFIRMED]) for session in self.review_history)
        denied = sum(len([h for h in session.hypotheses if h.status == HypothesisStatus.DENIED]) for session in self.review_history)
        conditional = sum(len([h for h in session.hypotheses if h.status == HypothesisStatus.CONDITIONAL]) for session in self.review_history)
        
        all_impacts = []
        for session in self.review_history:
            all_impacts.extend([h.impact_score for h in session.hypotheses])
        
        return {
            "total_sessions": len(self.review_history),
            "total_hypotheses": total_hypotheses,
            "confirmation_rate": confirmed / total_hypotheses if total_hypotheses > 0 else 0,
            "denial_rate": denied / total_hypotheses if total_hypotheses > 0 else 0,
            "conditional_rate": conditional / total_hypotheses if total_hypotheses > 0 else 0,
            "average_impact": sum(all_impacts) / len(all_impacts) if all_impacts else 0,
            "pending_hypotheses": len(self.pending_hypotheses)
        }
    
    def prioritize_hypotheses(self):
        """Prioritize pending hypotheses based on impact and confidence."""
        def priority_score(hypothesis):
            return hypothesis.confidence * hypothesis.impact_score
        
        self.pending_hypotheses.sort(key=priority_score, reverse=True)

# Factory function
def create_active_veto_system(brain_instance=None) -> ActiveVetoSystem:
    """Create and initialize an Active Veto System."""
    veto_system = ActiveVetoSystem(brain_instance)
    return veto_system
