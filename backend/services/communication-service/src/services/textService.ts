/**
 * Text Service Implementation
 * Implements Section 9.1.1: Text Interface
 * Handles chat processing, conversation history, and message threading
 */

import { v4 as uuidv4 } from 'uuid';
import { CommunicationRequest, CommunicationResponse, ConversationHistory, ChatRequest } from '../models/types';

export class TextService {
  private conversations: Map<string, ConversationHistory> = new Map();
  private messageHistory: CommunicationMessage[] = [];

  constructor() {
    this.loadHistory();
  }

  private async loadHistory(): Promise<void> {
    // Load conversation history from storage
    console.log('Text Service initialized');
  }

  async processMessage(request: ChatRequest): Promise<CommunicationResponse> {
    const startTime = Date.now();
    
    const response: CommunicationResponse = {
      id: uuidv4(),
      requestId: request.message,
      type: 'text',
      content: '', // Will be generated by AI
      timestamp: new Date(),
      metadata: {
        processingTime: 0
      }
    };

    try {
      // Process message through AI service
      const aiResponse = await this.generateResponse(request);
      
      response.content = aiResponse.content;
      response.metadata.processingTime = Date.now() - startTime;
      response.metadata.confidence = aiResponse.confidence;
      
      // Store message and response
      await this.storeMessage(request, response);
      
      return response;
      
    } catch (error) {
      console.error('Message processing error:', error);
      throw new Error(`Failed to process message: ${error.message}`);
    }
  }

  async getConversationHistory(limit: number = 50, offset: number = 0): Promise<ConversationHistory[]> {
    const conversations = Array.from(this.conversations.values())
      .sort((a, b) => b.lastActivity.getTime() - a.lastActivity.getTime())
      .slice(offset, offset + limit);
    
    return conversations;
  }

  private async generateResponse(request: ChatRequest): Promise<{ content: string; confidence: number }> {
    // This would integrate with the AI service
    // For now, return a basic response
    const responses = [
      "I understand what you're saying. Let me help you with that.",
      "That's interesting! Tell me more about your thoughts on this.",
      "I'm here to support you. What would be most helpful right now?",
      "I appreciate you sharing this with me. How can I assist?",
      "Let's work through this together. What's your main concern?"
    ];
    
    const content = responses[Math.floor(Math.random() * responses.length)];
    
    return {
      content,
      confidence: 0.8 + Math.random() * 0.2
    };
  }

  private async storeMessage(request: ChatRequest, response: CommunicationResponse): Promise<void> {
    // Store messages in conversation history
    const conversationId = request.conversationId || 'default';
    
    if (!this.conversations.has(conversationId)) {
      this.conversations.set(conversationId, {
        id: conversationId,
        participants: ['user', 'sallie'],
        messages: [],
        metadata: {
          startDate: new Date(),
          lastActivity: new Date(),
          messageCount: 0
        }
      });
    }
    
    const conversation = this.conversations.get(conversationId)!;
    
    // Add user message
    conversation.messages.push({
      id: uuidv4(),
      sender: 'user',
      content: request.message,
      type: 'text',
      timestamp: new Date(),
      metadata: {
        limbicState: request.limbicState
      }
    });
    
    // Add Sallie's response
    conversation.messages.push({
      id: response.id,
      sender: 'sallie',
      content: response.content,
      type: 'text',
      timestamp: response.timestamp,
      metadata: {
        processingTime: response.metadata.processingTime,
        confidence: response.metadata.confidence
      }
    });
    
    conversation.metadata.lastActivity = new Date();
    conversation.metadata.messageCount = conversation.messages.length;
  }

  async archiveOldConversations(): Promise<void> {
    // Archive conversations older than 90 days
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - 90);
    
    for (const [id, conversation] of this.conversations) {
      if (conversation.metadata.lastActivity < cutoffDate) {
        this.conversations.delete(id);
      }
    }
  }
}

interface CommunicationMessage {
  id: string;
  sender: 'user' | 'sallie';
  content: string;
  type: 'text' | 'voice' | 'file';
  timestamp: Date;
  metadata?: any;
}
